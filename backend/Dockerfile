# --- ЭТАП 1: Сборщик (Builder) ---
# Используем полную версию Node.js, чтобы иметь все инструменты для установки зависимостей.
# AS builder - даем этому этапу имя, чтобы ссылаться на него позже.
FROM node:18-alpine AS builder

# Устанавливаем рабочую директорию внутри контейнера.
WORKDIR /app

# Копируем package.json и package-lock.json ПЕРЕД остальным кодом.
# Это ключевая оптимизация. Docker кэширует этот слой. Если зависимости не менялись,
# npm install не будет запускаться при каждой сборке, что сильно ускоряет процесс.
COPY package*.json ./

# Устанавливаем ВСЕ зависимости, включая dev-зависимости, если они понадобятся для сборки.
# В твоем случае dev-зависимости (vitest, supertest) не нужны для прода, но это стандартная практика.
RUN npm install

# Теперь копируем весь остальной код приложения.
COPY . .


# --- ЭТАП 2: Финальный образ (Production) ---
# Начинаем с чистого, легковесного образа. В нем не будет ничего лишнего.
FROM node:18-alpine

WORKDIR /app

# Копируем package.json и package-lock.json снова.
COPY package*.json ./

# Устанавливаем ТОЛЬКО production-зависимости.
# npm ci - быстрее и строже, чем install, идеально для CI/CD.
# --omit=dev - флаг, который говорит "не ставить devDependencies".
# Это делает финальный образ меньше и безопаснее.
RUN npm ci --omit=dev

# Копируем код нашего приложения из этапа 'builder'.
# Мы не копируем все подряд, а только то, что было в рабочей директории builder'a.
COPY --from=builder /app .

# Устанавливаем пользователя 'node'.
# Это лучшая практика безопасности. Никогда не запускай приложения от root в контейнере.
USER node

# Сообщаем Docker, что наше приложение будет слушать порт 3001.
EXPOSE 3001

# Команда, которая будет запущена при старте контейнера.
# Используем JSON-синтаксис - это стандарт.
CMD [ "node", "server.js" ]